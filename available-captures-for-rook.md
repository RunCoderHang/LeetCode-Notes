## LeetCode每日一题（二十六）：可以被一步捕获的棋子数

在一个 8 x 8 的棋盘上，有一个白色的车（`Rook`），用字符 `'R'` 表示。棋盘上还可能存在空方块，白色的象（`Bishop`）以及黑色的卒（`pawn`），分别用字符 `'.'`，`'B'` 和 `'p'` 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：

* 棋手选择主动停下来。
* 棋子因到达棋盘的边缘而停下。
* 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
* 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。


你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。


示例 1：

<div align="left">
    <img width="202px" src="https://github.com/RunCoderHang/LeetCode-Notes/blob/master/image/1253_example_1_improved.png"></img>
</div>

```
输入：[
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
```

示例 2：

<div align="left">
    <img width="202px" src="https://github.com/RunCoderHang/LeetCode-Notes/blob/master/image/1253_example_2_improved.png"></img>
</div>

```
输入：[
[".",".",".",".",".",".",".","."],
[".","p","p","p","p","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","B","R","B","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","p","p","p","p",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：0
解释：
象阻止了车捕获任何卒。
```

示例 3：

<div align="left">
    <img width="202px" src="https://github.com/RunCoderHang/LeetCode-Notes/blob/master/image/1253_example_3_improved.png"></img>
</div>

```
输入：[
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","p",".",".",".","."],
["p","p",".","R",".","p","B","."],
[".",".",".",".",".",".",".","."],
[".",".",".","B",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。
```

提示：

* board.length == board[i].length == 8
* board[i][j] 可以是 'R'，'.'，'B' 或 'p'
* 只有一个格子上存在 board[i][j] == 'R'


## Solve

使用图中通用的方法，先找到车的位置，再上下左右四个方向“移动”。

找到象或者超过棋盘边界则 `break`，开始下一个方向寻找。找到了卒，同样 `break`，不过寻找成功次数 `+1` 。

```c++
class Solution {
public:
    int numRookCaptures(vector<vector<char>>& board) {
        // 上、下、左、右
        int dx[4] = {-1, 1, 0, 0};
        int dy[4] = {0, 0, -1, 1};

        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] == 'R') { // 找到白车所在的位置
                    int res = 0;
                    for (int k = 0; k < 4; k++) { // 分别判断白车的上、下、左、右四个方向
                        int x = i, y = j;
                        while (true) {
                            x += dx[k];
                            y += dy[k];
                            if (x < 0 || x >= 8 || y < 0 || y >= 8 || board[x][y] == 'B') {
                                break;
                            }
                            if (board[x][y] == 'p') {
                                res++;
                                break;
                            }
                        }
                    }
                    return res;
                }
            }
        }
        return 0;
    }
};
```

* 时间复杂度：**O(n^2)**
* 空间复杂度：**O(1)**

<div align="center">
    <hr style="height:1px;"/>
    <br>
    <img width="200px" src="https://github.com/RunCoderHang/LeetCode-Notes/blob/master/image/wxgzh-hang.png"></img>
</div>